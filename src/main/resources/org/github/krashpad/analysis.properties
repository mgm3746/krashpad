error.avx2.string.compare.to=Crash in String.compareTo(Object) compiled with AVX2 instruction set due to a hardware issue. Test disabling AVX with the following option: -XX:UseAVX=0. References: (1) https://access.redhat.com/solutions/6983539. (2) https://bugs.openjdk.org/browse/JDK-8240913.
error.bufferblob.flush_icache_stub=Crash in BufferBlob::flush_icache_stub. Reference: https://access.redhat.com/solutions/5658041.
error.cannot.get.library.information=Cannot get library information.
error.compiled.java.code=JVM crash when executing compiled java code. Reference: https://access.redhat.com/solutions/455823.
error.compiler.thread=JVM crash in CompilerThread. Reference: https://access.redhat.com/solutions/20195.
error.compiler.thread.c2.beautify.loops=JVM crash in C2 CompilerThread: "guarantee(n != NULL) failed: No Node." Reference: https://access.redhat.com/solutions/6792621.
error.compiler.thread.c2.ifnode.foldcompares=JVM crash in IfNode::fold_compares(PhaseIterGVN*). Reference: https://access.redhat.com/solutions/7034795.
error.compiler.thread.c2.mininode.ideal=JVM crash in MinINode::Ideal(PhaseGVN*, bool). Reference: https://access.redhat.com/solutions/6958611.
error.crash.native.library.unknown=Crash in 3rd party or unknown native library: 
error.crash.on.oome.heap=Crash due to "java.lang.OutOfMemoryError: Java heap space" in combination with -XX:+CrashOnOutOfMemoryError. Reference: https://access.redhat.com/solutions/37055.
error.direct.byte.buffer.contention=It appears there is an application issue resulting in 2 threads attempting to modify a java.nio.ByteBuffer at the same time (e.g. one thread closing/cleaning it while another thread tries to write to it). ByteBuffer is not thread safe and must be accessed in a synchronized manner. Reference: https://access.redhat.com/solutions/5625311.
error.dynatrace=Crash when executing Dynatrace code.
error.explicit.gc.disabled.eap7=Explicit garbage collection cannot be disabled on JBoss EAP7 because the IO subsystem uses direct memory (java.nio.DirectByteBuffer). The JVM uses explicit garbage collection to manage direct memory (to free space when MaxDirectMemorySize is reached), so disabling it can cause a memory leak. Remove -XX:+DisableExplicitGC, and if using the CMS or G1 collector, add -XX:+ExplicitGCInvokesConcurrent so explicit garbage collection is handled concurrently.
error.fpe=Floating point error. Check code for division by 0, modulo by 0, or integer overflow.
error.freetype.font.scaler.get.glyph.image.native=JVM crash due to a temporary font file being removed from java.io.tmpdir. Reference: https://access.redhat.com/solutions/4045621.
error.g1_par_scan_thread_state.copy_to_survivor_space=Crash in G1ParScanThreadState::copy_to_survivor_space. Reference: https://access.redhat.com/solutions/2075963.
error.gregoriancalendar.computetime=crash in java.util.GregorianCalendar.computeTime. Reference: https://access.redhat.com/solutions/7015004.
error.hashmap=Crash in java.util.HashMap. HashMap is not threadsafe. Check if the crash is due to multiple threads concurrently reading/writing to the HashMap.
error.itext.io=Crash in StubRoutines from iText I/O due to a threading issue in the iText library where a file is attempting to be read before it is completely written to disk. Reference: https://access.redhat.com/solutions/5665601.
error.jdk.version.unknown=Unknown JDK version.
error.jdk.version.unsupported=Unsupported JDK version. krashpad targets JDK8+. Analysis may be incomplete (e.g. unidentified log lines).
error.jdk8.deflater.contention=There is an application or operations invalid use case resulting in an attempt to modify a file while Java has it open. A workaround to avoid the crash is to disable memory mapping in ZipFile with -Dsun.zip.disableMemoryMapping=true (at the cost of some loss in performance), or upgrade to JDK 11. References: (1) https://access.redhat.com/solutions/2620091. (2) https://bugs.openjdk.org/browse/JDK-8145260.
error.jdk8.jfr.class.transformed=Crash when JFR event class is transformed. Reference: https://access.redhat.com/solutions/6764821.
error.jdk8.libc.cfree= Crash in libc cfree+0x1c fixed in OpenJDK8 u262. Reference: https://access.redhat.com/solutions/5015001.
error.jdk8.rhel7.power8.rpm.on.power9=It appears that the power8 rpm from rhel-7-for-power-le-rpms repo is installed on a POWER9 cpu. This is not tested/supported.
error.jdk8.shenandoah.mark.loop.work=Crash in GCTaskThread while Shenandoah collector concurrent marking. Reference: https://access.redhat.com/solutions/5581301.
error.jdk8.shenandoah.metadata.on.stack.mark=Crash in MetadataOnStackMark due to race condition. Fixed in OpenJDK8 u312. Reference: https://access.redhat.com/solutions/6225841.
error.jdk8.shenandoah.root.updater=ShenadoahRootUpdater bug fixed in OpenJDK8 u282. Reference: https://access.redhat.com/solutions/5581321.
error.jdk8.zipfile.contention=There is an application or operations invalid use case resulting in an attempt to modify a file while Java has it open. A workaround to avoid the crash is to disable memory mapping in ZipFile with -Dsun.zip.disableMemoryMapping=true (at the cost of some loss in performance), or upgrade to JDK 11. Backporting a fix to JDK8 would not address the root cause, and the OpenJDK developers have determined it is too risky. References: (1) https://access.redhat.com/solutions/6983666. (2) https://bugs.openjdk.org/browse/JDK-8145260.
error.jfr.pd.get.top.frame=Crash in JFR pd_get_top_frame_for_profiling. Reference: https://access.redhat.com/solutions/5964251.
error.jna=The crash involves JNA code. JNA is not part of the Java JDK. The JNA library is distributed with the application and is therefore application code and not supported by the JDK vendor. Next steps for troubleshooting should be from the JNA vendor. The JDK vendor will provide support for the underlying JDK if the JNA vendor finds an issue with a valid/supported use case.
error.jna.ffi_prep_closure_loc=Crash in JNA ffi_prep_closure_loc. Check if jna.tmpdir and/or the libffi tmp directory do not exist or have appropriate permissions to allow access. Reference: https://access.redhat.com/solutions/6991416.
error.jna.rh=The crash involves JNA code. JNA is not part of the Java JDK. The JNA library is distributed with the application and is therefore application code and not supported by Red Hat. Next steps for troubleshooting should be from the JNA vendor. Red Hat will provide support for the underlying JDK if the JNA vendor finds an issue with a valid/supported use case.
error.jss=Crash when executing Java Security Services (JSS) code, an interface between the JVM and Network Security Services (NSS). It supports most of the security standards and encryption technologies supported by NSS including communication through SSL/TLS network protocols.
error.jvm.dll=JVM crash inside jvm.dll. https://access.redhat.com/solutions/464203.
error.large.pages.hugetlbfs.explicit.jvm.yes.os.no=The JVM is configured to use Linux explicit hugepages, but the Linux kernel is not. Enable explicit hugepages support in the kernel. Reference: https://access.redhat.com/solutions/46326.
error.large.pages.thp.jvm.yes.os.always=The JVM is configured to request Linux Transparent Hugepage (THP) large pages, but the Linux kernel is configured for all memory (every 'mmap' of every process) to use THPs (/sys/kernel/mm/transparent_hugepage/enabled = 'always'). Some memory is not a good choice for THPs (e.g. thread stacks), so it is recommended to set /sys/kernel/mm/transparent_hugepage/enabled to 'madvise' so the JVM can restrict THP usage to memory allocated with madvise() with the MADV_HUGEPAGE flag. The JVM will mark heap (except with ZGC) and other large regions to use THP.
error.large.pages.thp.jvm.yes.os.never=The JVM is configured to use Linux Transparent Hugepage (THP) large pages, but the Linux kernel is not (/sys/kernel/mm/transparent_hugepage/enabled = 'never'). Set /sys/kernel/mm/transparent_hugepage/enabled is set to 'madvise'.
error.large.pages.zgc.shmem.zero=The JVM is configured to use large pages with the ZGC collector, but the Linux kernel is not properly configured to provide the large page backing. ZGC uses shmem huge pages for the heap, and none are available (ShmemHugePages = 0). Set the shmem_enabled mode to 'advise' (# echo advise > /sys/kernel/mm/transparent_hugepage/shmem_enabled) to enable shmem huge pages.
error.libaio.context.done=JVM crash in org.apache.activemq.artemis.nativo.jlibaio.LibaioContext.done() method. Reference: https://access.redhat.com/solutions/5080901.
error.libjvm.so=JVM crash inside libjvm.so. Reference: https://access.redhat.com/solutions/442903.
error.linkage=LinkageError detected (e.g. LinkageError, BootstrapMethodError, ClassCircularityError, ClassFormatError, ExceptionInInitializerError, IncompatibleClassChangeError, NoClassDefFoundError, UnsatisfiedLinkError, VerifyError). Class A has a dependency on class B, and class B has incompatibly changed after class A was compiled. Use a tool such as tattletale to look at packaged JDK/J2EE/application classes. Reference: https://access.redhat.com/solutions/800073.
error.logging.multiple=Parsing aborted due to multiple and/or mixed logging.
error.memory.corruption=Crash due to memory corruption. Corruption can happen in 3 places: (1) application code. (2) JDK code. (3) hardware.
error.module.entry.purge.reads=JVM crash in ModuleEntry::purge_reads or ModuleEntryTable::purge_all_module_reads. Reference: https://access.redhat.com/solutions/6268641.
error.module.entry.purge.reads.possible=JVM crash in ModuleEntry::purge_reads or ModuleEntryTable::purge_all_module_reads possible. Reference: https://access.redhat.com/solutions/6268641.
error.oome=Insufficient physical memory. Check if memory exhaustion is due solely to the JVM, or external processes are consuming significant amounts of memory.
error.oome.amq.cli=AMQ CLI crash due to insufficient memory. Verify the AMQ CLI is run from the ARTEMIS_BIN directory (ARTEMIS_HOME/bin) and not the ARTEMIS_INSTANCE_BIN (ARTEMIS_HOME/broker/bin) directory so the AMQ CLI will not inherit the AMQ broker JVM options.
error.oome.compiler.thread.c2.ssl.decode=VM crash in CompilerThread in sun.security.ssl.SSLEngineInputRecord::decodeInputRecord compile task due to insufficient physical memory. Reference: https://access.redhat.com/solutions/6973255.
error.oome.external=Insufficient physical memory when the JVM memory is <95% physical memory. External process(es) consuming memory. Possible resolutions: (1) Increase physical memory. (2) Slim external processes.
error.oome.external.or.hypervisor=Insufficient physical memory when the JVM memory is <95% physical memory. Determine which of the following is consuming the unaccounted memory: (1) External process(es), (2) Hypervisor memory ballooning. Possible resolutions: (1) Increase physical memory. (2) Slim external processes. (3) Do hypervisor tuning to ensure memory swapping does not happen (e.g. reserve virtual machine memory).
error.oome.external.startup=It appears there is not enough physical memory for the JVM to start. Decrease memory demands on the box and/or increase the available physical memory. The JVM process size is < 50% of available memory so the likely candidates for memory slimming are processes outside the JVM. If collocating multiple JVM instances, reduce JVM memory needs (e.g. decrease heap size) and/or decrease the number of instances. If a VM environment, check if memory ballooning has consumed memory on the VM.
error.oome.jboss.version=JBoss version check (e.g. standalone.sh --version) crash due to insufficient memory. The version check launches a full JVM with JBoss heap settings, so it's a very resource-intensive way to check the version string. A more lightweight approach would be to use the JBoss CLI and run "patch info".
error.oome.jvm=Insufficient physical memory when the JVM heap + metaspace + class pointers + thread stack is >=95% physical memory. Either increase physical memory or slim the JVM process (heap, metaspace, native memory, thread stack size, number of threads, etc.).
error.oome.jvm.startup=It appears there is not enough physical memory for the JVM to start. Either reduce the JVM memory needs (e.g. decrease the heap size), eliminate other processes outside the JVM competing for memory, and/or increase the available physical memory.
error.oome.rlimit=The Out of Memory Error appears to be caused by a resource limit (rlimit) being reached. Check if the max user processes (nproc), kernel max number of threads (kernel.pid_max), open file limit (nofile), etc. is being reached. Reference: https://access.redhat.com/solutions/46410.
error.oome.rlimit.max.map.count=The memory allocation failure appears to be caused by max_map_count being reached.
error.oome.rlimit.oops=The Out of Memory Error appears to be caused by one of the following limits being reached: (1) The native heap reached the java heap base address. Set -XX:HeapBaseMinAddress=n higher or disable CompressedOops with -XX:-UseCompressedOops. Reference: https://access.redhat.com/solutions/2697961. (2) A resource limit (rlimit) is reached. Check if the max user processes (nproc), kernel max number of threads (kernel.pid_max), open file limit (nofile), etc. is being reached. Reference: https://access.redhat.com/solutions/46410.
error.oome.rlimit.oops.startup=The Out of Memory Error preventing the JVM from starting appears to be caused by one of the following limits being reached: (1) The native heap reached the java heap base address. Set -XX:HeapBaseMinAddress=n higher or disable CompressedOops with -XX:-UseCompressedOops. Reference: https://access.redhat.com/solutions/2697961. (2) A resource limit (rlimit) is reached. Check if the max user processes (nproc), kernel max number of threads (kernel.pid_max), open file limit (nofile), etc. is being reached. Reference: https://access.redhat.com/solutions/46410.
error.oome.rlimit.overcommit=The Out of Memory Error appears to be caused by one of the following limits being reached: (1) Unused memory committed to other processes is inaccessible. Check if vm.overcommit_memory=2 is causing the kernel to deny requests for memory. (2) A resource limit (rlimit) is reached. Check if the max user processes (nproc), kernel max number of threads (kernel.pid_max), open file limit (nofile), etc. is being reached.
error.oome.rlimit.overcommit.startup=The Out of Memory Error preventing the JVM from starting appears to be caused by one of the following limits being reached: (1) Unused memory committed to other processes is inaccessible. Check if vm.overcommit_memory=2 is causing the kernel to deny requests for memory. (2) A resource limit (rlimit) is reached. Check if the max user processes (nproc), kernel max number of threads (kernel.pid_max), open file limit (nofile), etc. is being reached. Reference: https://access.redhat.com/solutions/46410.
error.oome.rlimit.startup=The Out of Memory Error preventing the JVM from starting appears to be caused by a resource limit (rlimit) being reached. Check if the max user processes (nproc), kernel max number of threads (kernel.pid_max), open file limit (nofile), etc. is being reached. Reference: https://access.redhat.com/solutions/46410.
error.oome.wlimit=The Out of Memory Error appears to be caused by some Windows limit being reached.
error.oome.wlimit.page.file=The Out of Memory Error appears to be caused by Windows page file (swap) exhaustion.
error.oome.wlimit.page.file.startup=The Out of Memory Error preventing the JVM from starting appears to be caused by Windows page file (swap) exhaustion.
error.oome.wlimit.oops=The Out of Memory Error preventing the JVM from starting appears to be caused by one of the following limits being reached: (1) The native heap reached the java heap base address. Set -XX:HeapBaseMinAddress=n higher or disable CompressedOops with -XX:-UseCompressedOops. Reference: https://access.redhat.com/solutions/2697961. (2) Some Windows limit is reached. Reference: https://access.redhat.com/solutions/46410.
error.oome.wlimit.startup=The Out of Memory Error preventing the JVM from starting appears to be caused by some Windows limit being reached.
error.oome.native.or.external=Insufficient physical memory when the JVM heap + metaspace + class pointers + thread stack is <95% physical memory. Determine which of the following is consuming the unaccounted memory: (1) JVM native memory, (2) External process(es), (3) Hypervisor memory ballooning. Possible resolutions: (1) Increase physical memory. (2) Slim JVM (heap, metaspace, native memory, thread stack size, number of threads, etc.). (3) Slim external processes. (4) Do hypervisor tuning to ensure memory swapping does not happen (e.g. reserve virtual machine memory).
error.oome.oops=Insufficient physical memory due to one of the following reasons: (1) The JVM or external processes are consuming significant amounts of memory. (2) The native heap reached the java heap base address. Set -XX:HeapBaseMinAddress=n higher or disable CompressedOops with -XX:-UseCompressedOops. Reference: https://access.redhat.com/solutions/2697961.
error.oome.overcommit.rlimit=The Out of Memory Error appears to be due to vm.overcommit_memory=2 causing the kernel to deny the requested allocation because it is larger than CommitLimit - Committed_AS - user_reserve_kbytes - admin_reserve_kbytes. Verify vm.overcommit_memory=2. If it does not, the crash is due to a resource limit (rlimit) being reached. Check if the max user processes (nproc), kernel max number of threads (kernel.pid_max), open file limit (nofile), etc. is being reached.
error.oome.overcommit.rlimit.startup=The Out of Memory Error preventing the JVM from starting appears to be due to vm.overcommit_memory=2 causing the kernel to deny the requested allocation because it is larger than CommitLimit - Committed_AS - user_reserve_kbytes - admin_reserve_kbytes. Verify vm.overcommit_memory=2. If it does not, the crash is due to a resource limit (rlimit) being reached. Check if the max user processes (nproc), kernel max number of threads (kernel.pid_max), open file limit (nofile), etc. is being reached.
error.oome.thread.leak=The Out of Memory Error appears to be caused by a thread leak causing a limit to be reached (e.g. the max user processes [nproc] resource limit [rlimit]).
error.oome.thread.leak.eap.executor.pool=The Out of Memory Error appears to be caused by a Wildfly or JBoss EAP executor pool leak causing a limit to be reached (e.g. the max user processes [nproc] resource limit [rlimit]). Reference: https://access.redhat.com/solutions/68039.
error.oome.thrown.java.heap=OutOfMemoryError other than "Metaspace" or "Compressed class space" is caught and thrown. OutOfMemoryError should not be caught, as it leaves the JVM in an undetermined state. Check the relevant JDK or application code to determine the underlying cause.
error.oome.thrown.metaspace="OutOfMemoryError: Metaspace" is caught and thrown. OutOfMemoryError should not be caught, as it leaves the JVM in an undetermined state. Either there is unintended metaspace retention, or the metaspace is too small. Reference: https://access.redhat.com/solutions/2038983.
error.oome.thrown.comp.class.space="OutOfMemoryError: Compressed class space" is caught and thrown. OutOfMemoryError should not be caught, as it leaves the JVM in an undetermined state. The compressed class space is too small. Reference: https://access.redhat.com/solutions/2132101.
error.oome.tomcat.shutdown=Tomcat shutdown crash due to insufficient memory. Verify tomcat jvm options are set through CATALINA_OPTS, not JAVA_OPTS. Reference: https://access.redhat.com/solutions/909533.
error.oracle.jdbc.jdk.incompatible=The Oracle JDBC driver and JDK versions do not appear to be compatible. Verify with Oracle support. Reference: https://www.oracle.com/database/technologies/faq-jdbc.html.
error.oracle.jdbc.oci.driver=Crash related to Oracle JDBC OCI (native) driver code. Reference: https://access.redhat.com/solutions/304633.
error.oracle.jdbc.oci.loading=Crash after loading Oracle JDBC OCI (native) database driver.
error.pointer.invalid=The crash occurred dereferencing an invalid pointer (si_addr: 0xffffffffffffffff). Something has caused memory corruption: (1) A race condition. (2) A system update was made while the JVM was running, resulting in a bad pointer to an underlying library or resource.
error.pointer.null=The crash occurred dereferencing a null pointer (si_addr: 0x0000000000000000). Something has caused memory corruption: (1) A race condition. (2) A system update was made while the JVM was running, resulting in a bad pointer to an underlying library or resource.
error.postgresql.jdbc.jdk8.incompatible=The PostgreSQL JDBC driver does not appear to be compatible with JDK8. Verify with PostgreSQL support. Reference: https://jdbc.postgresql.org/.
error.ps_promotion_manager.copy_to_survivor_space=Crash in PSPromotionManager::copy_to_survivor_space. Reference: https://access.redhat.com/solutions/6981289.
error.pthread.getcpuclockid=Crash in pthread_getcpuclockid when using jstack to get a thread dump. There is JNI code that is not calling DetachCurrentThread after using AttachCurrentThreadAsDaemon, resulting in jstack trying to access a bad memory address. Reference: https://access.redhat.com/solutions/5317181.
error.stackoverflow=StackOverflowError detected. Either there is unintended recursion, or the stack is too small. Check if StackOverflowError is being caught and preventing the JVM from exiting. StackOverflowError should not be caught, as it leaves the JVM in an undetermined state. Reference: https://access.redhat.com/solutions/27221.
error.stubroutines=JVM crash in StubRoutines. Reference: https://access.redhat.com/solutions/4466551.
error.timeout=Timeout occurred during error reporting.
error.wily=Crash when executing Wily/DX APM code.
info.app.dynamics.detected=App Dynamics instrumentation detected.
info.app.dynamics.possible=App Dynamics instrumentation possible.
info.cgroup.version=cgroup version: 
info.cgroup.memory.limit=The memory available to the JVM is restricted by cgroups memory_limit_in_bytes.
info.compiled.java.code.avx2=The code was compiled with the AVX2 instruction set. This has been know to cause register corruption issues on some hardware. Test disabling AVX with the following option: -XX:UseAVX=0.
info.dbcp2=Apache Commons Pool 2: https://commons.apache.org/proper/commons-dbcp/.
info.dynatrace=Dynatrace detected.
info.fips.mode=OS running in FIPS mode?
info.hyperv=HyperV environment.
info.ibm.toolkit=IBM Toolbox for Java library detected (support for connections to OS/400, i5/OS, or IBM i systems). Reference: https://sourceforge.net/projects/jt400/.
info.itext=iText PDF library detected.
info.jss=Java Security Services (JSS), an interface between the JVM and Network Security Services (NSS), detected. It supports most of the security standards and encryption technologies supported by NSS including communication through SSL/TLS network protocols.
info.java.sr.signum=The _JAVA_SR_SIGNUM environment variable is being used to map a signal to SIGUSR1 (suspend/resume).
info.jdk.32=32-bit JDK.
info.jdk.ancient=The JDK is very old (>1 yr). Has the application been running without issue in production for a long time? Has something changed recently (e.g. application upgrade, load, etc.) that might have triggered the issue?
info.jffi=Check Java Foreign Function Interface (JFFI) usage. Reference: https://github.com/jnr/jffi.
info.jna=Check Java Native Access (JNA) usage. Reference: https://github.com/java-native-access.
info.jvm.startup.fails=The JVM fails to start.
info.jvm.user.ne.username=The USERNAME environment variable is different than the user the JVM process is running under.
info.large.pages.consider.thp.os.always=The Linux kernel is configured for all memory (every 'mmap' of every process) to use Transparent Hugepage (THP) large pages (/sys/kernel/mm/transparent_hugepage/enabled = 'always'). Some memory is not a good choice for THPs (e.g. thread stacks). It is recommended to consider explicitly enabling large page support, which can provide performance improvements with large heaps (> 4GB). Reference: https://access.redhat.com/solutions/22929.
info.large.pages.thp.jvm.yes.os.madvise=The JVM is configured to request Linux Transparent Hugepage (THP) large pages, and the Linux kernel is properly configured to back large pages requests with THPs (/sys/kernel/mm/transparent_hugepage/enabled = 'madvise').
info.large.pages.thp.jvm.yes.os.undetermined=The JVM is configured to request Linux Transparent Hugepage (THP) large pages, but Linux kernel support is undetermined. Check that /sys/kernel/mm/transparent_hugepage/enabled is set to 'madvise'.
info.ld.so.preload=/etc/ld.so.preload is used to preload libraries.
info.microsoft.sql.server.native=Microsoft SQL Server native driver detected.
info.native.libraries.google=Google native libraries detected: 
info.native.libraries.jboss=JBoss native libraries detected: 
info.native.libraries.tomcat=Tomcat native libraries detected: 
info.native.libraries.unknown=3rd party or unknown native libraries: 
info.native.libraries.vmware=VMware native libraries detected: 
info.oome.startup.heap.min.equal.max=It may be possible to start the JVM by setting the initial heap size (-Xms, -XX:InitialHeapSize) to a smaller value than the maximum heap size and doing tuning to minimize the Java process size. Reference: https://access.redhat.com/solutions/6325331.
info.opts.none=No JVM options (unconstrained).
info.opts.unknown=JVM options unknown (missing).
info.oracle.jdbc.oci=Oracle JDBC OCI (native) driver detected.
info.overcommit.disabled.ratio.100=It appears that memory overcommit is disabled (vm.overcommit_memory=2) with a limit of 100% physical memory (vm.overcommit_ratio=100 or vm.overcommit_kbytes=MemTotal).
info.pki_tomcat=The application appears to be one of the following tomcat based certificate systems: (1) Red Hat Certificate System (RHCS), (2) Red Hat Enterprise Linux (RHEL) Identity Management (IdM), (3) Dogtag Certificate System (the upstream for RHCS and IdM).
info.postgresql.connection=Crash when connecting to PostgreSQL database.
info.rh.build.centos=Red Hat build of OpenJDK on CentOS.
info.rh.build.linux.zip=Red Hat build of OpenJDK Linux zip install.
info.rh.build.not=JDK does not appear to be a Red Hat build.
info.rh.build.possible=Red Hat build of OpenJDK possible, but not positively identified.
info.rh.build.rpm.based=Red Hat build of OpenJDK from rpm (e.g. jlink custom runtime, sym link to rpm install, rpm extract).
info.rh.build.rpm.install=Red Hat build of OpenJDK rpm install.
info.rh.build.windows.zip=Red Hat build of OpenJDK Windows zip install.
info.rh.opt.experimental.shenandoah=Shenandoah is not an experimental garbage collector in the Red Hat build of OpenJDK and does not require -XX:+UnlockExperimentalVMOptions.
info.rhel9.jdk8=JDK8 is supported on RHEL9, but the system JDK is JDK11 (i.e. RHEL tooling requires JDK11+).
info.shutdown=JVM crash during shutdown safepoint.
info.sigcode.bus.adraln=Signal code BUS_ADRALN: The memory address that has an invalid address alignment for the CPU.
info.sigcode.bus.adrerr=Signal code BUS_ADRERR: The memory address does not exist.
info.sigcode.bus.adrerr.linux=Signal code BUS_ADRERR: The memory address does not exist. This can happen on Linux when an mmap'ed file is truncated (e.g. a threading issue where 2 threads access a file at the same time).
info.sigcode.bus.objerr=Signal code BUS_OBJERR: Hardware issue.
info.sigcode.fpe.intdiv=Signal code FPE_INTDIV: Floating point error.
info.sigcode.ill.illopn=Signal code ILL_ILLOPN: Illegal operand.
info.sigcode.segv.accerr=Signal code SEGV_ACCERR: The access is not allowed. For example: (1) Attempting to write to read-only memory. (2) Attempting to write to protected (OS) memory. (3) Attempting to access an array at an index greater than the array size (out of bounds). (4) Attempting to access an invalid entry in a HashMap.
info.sigcode.segv.maperr=Signal code SEGV_MAPERR: The memory address does not exist in the application address space. For example: (1) Dereferencing a null pointer. (2) A corrupted pointer. (3) Stack overflow.
info.sigcode.si.kernel=Signal code SI_KERNEL: Sent by the kernel. This may indicate a hardware, kernel, or virtualization issue. Test memory by running memtest86+ or memtester. References: (1) https://access.redhat.com/solutions/15693. (2) https://shipilev.net/jvm/test-your-memory/#_run_memtester8.
info.sigcode.si.user=Signal code SI_USER: Sent by a user process (e.g. calling 'kill', 'sigqueue', 'abort', 'raise', etc.).
info.signo.exception.access.violation=EXCEPTION_ACCESS_VIOLATION: Segmentation fault. Accessing valid memory in an invalid way.
info.signo.exception.stack.overflow=EXCEPTION_STACK_OVERFLOW: Stack overflow. Either there is unintended recursion, or the stack is too small. Reference: https://access.redhat.com/solutions/27221.
info.signo.sigbus=Signal number SIGBUS: Invalid memory address.
info.signo.sigfpe=Signal number SIGFPE: Floating point error.
info.signo.sigill=Signal number SIGILL: Illegal instruction at the processor.
info.signo.sigsegv=Signal number SIGSEGV: Segmentation fault. Accessing valid memory in an invalid way.
info.stack.freespace.gt.stack.size=The current thread was created with a custom stackSize (the stack free space reported is greater than the stack size set on the command line [or default]).
info.stack.no.vm.code=The stack trace does not contain VM code.
info.storage.aws=AWS block storage.
info.storage.nfs=NFS storage.
info.storage.unknown=Unknown storage (can be determined with lsblk output).
info.swap.disabled=Swap is disabled. This can be an indication the JVM is running in a container environment. Reference: https://access.redhat.com/solutions/3242331.
info.swapping=>5% swap space being used at the time of the crash. This is not necessarily bad. It is only a snapshot in time, and it doesn't necessarily mean the Java process is swapping. However, since swapping is very bad for Java performance, it should be verified that the Java process is indeed not swapping.
info.threads.many=Many threads (>1,000).
info.truncated=Truncated fatal error log.
info.vmware=VMWare environment.
info.vm.operation.bulk.revoke.bias=Crash happening during a bulk operation when the compiler has to recompile previously compiled code due to the compiled code no longer being valid (e.g. a dynamic object has changed) or with tiered compilation when client compiled code is replaced with server compiled code.
info.vm.operation.concurrent.gc=Crash happening during a concurrent GC stop-the-world operation (e.g. remark, cleanup).
info.vm.operation.heap.dump=Crash happening during a heap dump.
info.vm.operation.thread.dump=Crash happening during a thread dump.
info.wily=Wily/DX APM detected.
warn.cms.incremental.mode=The CMS collector is run in incremental mode. Concurrent phases are periodically stopped so application threads can run. This is useful on systems with 1-2 processors that cannot afford to dedicate cpu to the concurrent phases. Remove -XX:+CMSIncrementalMode unless testing has shown it improves performance.
warn.dynatrace=Stack contains Dynatrace code.
warn.experimental.ergonomic=The following experimental options are being set by ergonomics: 
warn.explicit.huge.pages.os.yes.jvm.no=The OS is configured to use explicit huge pages, but the JVM is not. If it is intended for the JVM to use explicit huge pages, enable large page support. Reference: https://access.redhat.com/solutions/22926.
warn.fatal.error.log.ancient=The fatal error log is very old (>30 days).
warn.heap.plus.metaspace.gt.physical.memory.swap=The memory reserved for the heap and metaspace is greater than the physical memory. This can lead to swapping (very bad for Java performance) or the process being terminated due to hitting a limit (e.g. MemAvailable, oom killer). Either increase physical memory or decrease heap size to avoid swapping. The memory required by the JVM process is the sum of the following: (1) Heap. (2) Metaspace. (3) Thread Stack (thread stack size X number of threads). (4) JVM native memory. (5) A safety factor.
warn.heap.plus.metaspace.gt.physical.memory.noswap=The memory reserved for the heap and metaspace is greater than the physical memory. This can lead to the process being terminated due to hitting a limit (e.g. MemAvailable, oom killer). Either increase physical memory or decrease heap size. The memory required by the JVM process is the sum of the following: (1) Heap. (2) Metaspace. (3) Thread Stack (thread stack size X number of threads). (4) JVM native memory. (5) A safety factor.
warn.itext=Stack contains iText code.
warn.jdk.debug.symbols=Verify the JDK debug symbols are installed. Debug symbols can provide more detailed information in the fatal error log that is critical for analyzing issues in VM code. If they are not installed, reproduce the issue with the JDK debug symbols installed. Reference: https://access.redhat.com/solutions/5419761.
warn.jdk.not.latest=JDK is not the latest release
warn.jdk.not.lts=JDK is not a Long Term Support (LTS) version.
warn.jss=Stack contains Java Security Services (JSS) code, an interface between the JVM and Network Security Services (NSS). It supports most of the security standards and encryption technologies supported by NSS including communication through SSL/TLS network protocols.
warn.lucene=Stack contains Lucene code.
warn.max.map.count.rlimit=The number of memory map areas in the Dynamic Libraries section is within 1% of the max_map_count limit.
warn.max.map.count.rlimit.possible=The number of memory map areas in the Dynamic Libraries section is very close to the default max_map_count limit (65530).
warn.max.ram.limit=MaxRAMPercentage is being applied to the default MaxRAM (128g) because the system has >128g available memory. If this is not desired, explicitly set a higher MaxRAM (e.g. -XX:MaxRAM=256g). Fixed in JDK13+. Reference: https://bugs.openjdk.org/browse/JDK-8222252.
warn.mmap.deleted=One or more mmapped resources are in a deleted state. Check if there is an issue preventing the MappedByteBuffer from being garbage collected (e.g. no regular GC because the heap is too large).
warn.memory.external=External processes are consuming significant amounts of memory: 
warn.oom.g1=The G1 collector does not manage memory footprint as efficiently as other collectors. Consider moving to the parallel collector or Shenandoah to decrease memory demands.
warn.oracle.jdbc.oci.connection=Crash when connecting to Oracle database using JDBC OCI (native) driver.
warn.page.file.small=The page file is undersized (less than physical memory). Reference: https://learn.microsoft.com/en-us/sharepoint/technical-reference/the-paging-file-size-should-exceed-the-amount-of-physical-ram-in-the-system.
warn.rhel.jdk.rpm.mismatch=RHEL/JDK rpm version mismatch: 
warn.rhel6=RHEL6 reached end of Maintenance Support II in November 2020. There will be no more RH builds of OpenJDK for RHEL6. Reference: https://access.redhat.com/solutions/6033241.
warn.rhel7.els.unsupported.version=Unsupported RHEL7 version. RHEL7 reached extended life cycle support (ELS) phase on July 1, 2024, and only final minor release 7.9 is supported.
warn.rhel7.power9=RHEL7 Power9 reached end of Maintenance Support II in May 2021 and is in Extended Update Phase. Red Hat will provide limited ongoing technical support. No bug fixes, security fixes, hardware enablement or root-cause analysis will be available during this phase, and support will be provided on existing installations only. Reference: https://access.redhat.com/support/policy/updates/errata/.
warn.swap.disabled.cms=The CMS collector is generally not appropriate when swap is disabled. It is recommended to use a collector that has better memory management like the parallel collector or Shenandoah.
warn.swap.disabled.g1=The G1 collector is generally not appropriate when swap is disabled. It is recommended to use a collector that has better memory management like the parallel collector or Shenandoah.
warn.swapped.out=JVM process swapped out memory: 
warn.swapping=Os/container swap usage >= 20%. Memory usage should be monitored to determine if physical memory should be increased and/or memory demands decreased.
warn.thp.os.always=The Linux kernel is configured for all memory (every 'mmap' of every process) to use Transparent Hugepage (THP) large pages (/sys/kernel/mm/transparent_hugepage/enabled = 'always') on a JDK version known to cause memory bloat and performance issues or JDK version undetermined. Fixed in JDK17u10 and JDK21u1. Reference: https://bugs.openjdk.org/browse/JDK-8312182.
warn.threads.many=Many threads (>5,000).
warn.unidentified.log.line=Unidentified log line(s). Please submit an issue so we can investigate: https://github.com/mgm3746/krashpad/issues. If attaching a fatal error log, be sure to review it and remove any sensitive information.
warn.vm.operation.thread.dump.jvmti=Crash happening during a thread dump initiated by an external tool calling the JVM tool interface (JVM TI).
warn.wily=Stack contains Wily/DX APM code.